const isArray = thing => Array.isArray(thing);
const isObject = thing => thing instanceof Object && !isArray(thing);
const isString = thing => typeof thing === 'string';

class AssertionModule {
  constructor() {
    this.name = 'AssertionModule';
  }

  optionsTransformer(options, docxtemplater) {
    if (!options || !docxtemplater || !docxtemplater.modules) {
      throw new Error('Invalid arguments');
    }

    docxtemplater.modules.forEach(module => {
      if (!module.name) {
        throw new Error('Unnamed module');
      }
    });

    return options;
  }

  preparse(parsed) {
    if (!isArray(parsed)) {
      throw new Error('Parsed should be an array');
    }
  }

  matchers(options) {
    if (!options || !options.modules || !isArray(options.modules)) {
      throw new Error('Invalid options');
    }

    return [];
  }

  parse(placeholderContent, options) {
    if (!isString(placeholderContent)) {
      throw new Error('placeholderContent should be a string');
    }

    if (
      typeof options !== 'object' ||
      !options.type ||
      !options.position ||
      !options.filePath ||
      !options.contentType ||
      !options.lIndex
    ) {
      throw new Error('Missing required properties');
    }

    if (typeof options.type !== 'string') {
      throw new Error('parsed contains part without type');
    }

    if (options.type !== 'delimiter') {
      throw new Error(`parsed contains part with invalid type : '${options.type}'`);
    }

    if (options.position !== 'end') {
      throw new Error(`parsed contains part with invalid position : '${options.position}'`);
    }

    if (typeof options.filePath !== 'string' || options.filePath.length === 0) {
      throw new Error('parsed contains part without filePath');
    }

    if (typeof options.contentType !== 'string' || options.contentType.length === 0) {
      throw new Error('parsed contains part without contentType');
    }

    if (!options.lIndex) {
      throw new Error('parsed contains part without lIndex');
    }
  }

  postparse(parsed, { filePath, contentType }) {
    if (!isArray(parsed)) {
      throw new Error('Parsed should be an array');
    }

    if (typeof filePath !== 'string') {
      throw new Error('filePath should be a string');
    }

    if (typeof contentType !== 'string') {
      throw new Error('contentType should be a string');
    }

    for (const [i, part] of parsed.entries()) {
      if (!part) {
        console.log(JSON.stringify({ context: parsed.slice(i - 2, i + 2) }));
        throw new Error('postparsed contains falsy value');
      }

      if (typeof part.type !== 'string') {
        console.log(JSON.stringify({ context: parsed.slice(i - 2, i + 2) }));
        throw new Error('postparsed contains part without type');
      }

      if (
        ['content', 'tag', 'placeholder'].indexOf(part.type) === -1
      ) {
        console.log(JSON.stringify({ context: parsed.slice(i - 2, i + 2) }));
        throw new Error(`postparsed contains part with invalid type : '${part.type}'`);
      }
    }
  }

  render(part, { filePath, contentType }) {
    if (
      !isObject(part) ||
      typeof filePath !== 'string' ||
      typeof contentType !== 'string'
    ) {
      throw new Error('Invalid arguments');
    }
  }

  postrender(parts) {
    if (!isArray(parts)) {
      throw new Error('Parts should be an array');
    }

    return parts;
  }
}

module.exports = AssertionModule;
