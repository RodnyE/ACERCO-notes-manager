"use strict";

const repeat = require("./string-repeat.js");

function getIndent(indent) {
  return repeat("    ", indent);
}

function normalizeValue(value) {
  return value.replace(/&#([0-9]+);/g, function (_, int) {
    return "&#x" + parseInt(int, 10).toString(16).toUpperCase() + ";";
  });
}

function attributeSorter(attributes) {
  const sortedAttrs = attributes.slice();
  sortedAttrs.sort((a, b) => {
    const keyA = a.key.replace(/[\t\r\n]/g, "").toLowerCase();
    const keyB = b.key.replace(/[\t\r\n]/g, "").toLowerCase();
    if (keyA < keyB) {
      return -1;
    }
    if (keyA > keyB) {
      return 1;
    }
    return 0;
  });

  return sortedAttrs;
}

function xmlprettify(xml) {
  const result = "";
  const skip = 0;
  const indent = 0;
  const parsed = miniparser(xml);
  let level = 0;
  const namespaces = [];

  parsed.forEach((node) => {
    if (skip > 0) {
      skip--;
      return;
    }

    if (node.type === "processing-instruction") {
      result += node.value + "\n";
    } else if (node.type === "opening") {
      const indentStr = getIndent(indent + level);
      result += `${indentStr}<${node.value}`;
      if (node.attributes.length > 0) {
        const sortedAttrs = attributeSorter(node.attributes);
        const attrStrings = sortedAttrs.map(
          (attr) => `${attr.key}="${normalizeValue(attr.value)}"`
        );
        result += ` ${attrStrings.join(" ")}`;
      }
      if (node.isSelfClosing) {
        result += " />\n";
      } else {
        result += ">\n";
      }
      level += node.isSelfClosing ? 0 : 1;
      namespaces.push(getNamespaces(sortedAttrs));
    } else if (node.type === "closing") {
      level -= 1;
      const indentStr = getIndent(indent + level);
      result += `${indentStr}</${node.value}>\n`;
      namespaces.pop();
    } else if (node.type === "content") {
      const content = node.value
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
      result += content;
    }
  });

  if (indent !== 0) {
    throw new Error("Malformed XML indent at the end");
  }

  return result;
}

function getNamespaces(attributes) {
  return attributes.filter((attr) => attr.key.startsWith("xmlns"));
}

function miniparser(xml) {
  let cursor = 0;
  let state = "outside";
  let currentType = "";
  let content = "";
  const renderedArray = [];
  let level = 0;
  let namespaces = [];

  while (cursor < xml.length) {
    if (state === "outside") {
      const opening = xml.indexOf("<", cursor);
      if (opening !== -1) {
        if (opening !== cursor) {
          content = xml.substr(cursor, opening - cursor);
          renderedArray.push({
            type: "content",
            value: content,
          });
        }
        state = "inside";
        cursor = opening;
      } else {
        const content = xml.substr(cursor);
        renderedArray.push({
          type: "content",
          value: content,
        });
        return renderedArray;
      }
    }

    if (state === "inside") {
      const closing = xml.indexOf(">", cursor);
      if (closing !== -1) {
        let inAttr = false;
        let i = cursor;
        while (inAttr || xml[i] !== ">") {
          i++;
          if (xml[i] === '"') {
            inAttr = !inAttr;
          }
        }
        closing = i;
        const tag = xml.substr(cursor, closing - cursor + 1);
        const isSingle = Boolean(tag.match(/^<.+ \/>$/));
        const isClosing = Boolean(tag.match(/^<\/.+>/));
        const isProcessingInstruction = Boolean(
          tag.match(/^<\?.*\?>$/)
        );

        state = "outside";
        cursor = closing + 1;

        if (isProcessingInstruction) {
          const encodingRegex = / encoding="([^"]+)"/;
          if (encodingRegex.test(tag)) {
            tag = tag.replace(
              encodingRegex,
              function (x, encoding) {
                encoding = encoding.toUpperCase();
                if (encoding === "UTF-8") {
                  return "";
                }
                return " encoding=\"".concat(encoding, "\"");
              }
            );
          }
          renderedArray.push({
            type: "processing-instruction",
            value: tag,
          });
        } else if (isSingle) {
          const tagParts = tag.split(" ");
          const tagName = tagParts.shift();
          const tagAttrs = tagParts.map((attr) => {
            const attrParts = attr.split("=");
            return {
              key: attrParts[0],
              value: attrParts[1].slice(1, -1),
            };
          });
          const isSelfClosing = tag.endsWith(" />");
          const sortedAttrs = attributeSorter(tagAttrs);
          const attrStrings = sortedAttrs.map(
            (attr) => `${attr.key}="${normalizeValue(attr.value)}"`
          );
          const tagString = `${tagName} ${attrStrings.join(" ")}${
            isSelfClosing ? " /" : ""
          }`;
          renderedArray.push({
            type: "single",
            value: tagString,
            attributes: tagAttrs,
            isSelfClosing,
          });
        } else if (isClosing) {
          const tagParts = tag.split("/");
          const tagName = tagParts[1].slice(2, -1);
          renderedArray.push({
            type: "closing",
            value: tagName,
          });
        } else {
          const tagParts = tag.split(" ");
          const tagName = tagParts.shift();
          const tagAttrs = tagParts.map((attr) => {
            const attrParts = attr.split("=");
            return {
              key: attrParts[0],
              value: attrParts[1].slice(1, -1),
            };
          });
          const sortedAttrs = attributeSorter(tagAttrs);
          const attrStrings = sortedAttrs.map(
            (attr) => `${attr.key}="${normalizeValue(attr.value)}"`
          );
          const tagString = `${tagName} ${attrStrings.join(" ")}`;
          renderedArray.push({
            type: "opening",
            value: tagName,
            attributes: tagAttrs,
            isSelfClosing: tag.endsWith(" />"),
          });
          namespaces.push(getNamespaces(sortedAttrs));
          level += 1;
        }
      } else {
        const content = xml.substr(cursor);
        renderedArray.push({
          type: "content",
          value: content,
        });
        return renderedArray;
      }
    }
  }

  return renderedArray;
}

module.exports = xmlprettify;
