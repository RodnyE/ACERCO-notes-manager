const path = require("path");
const _ = require("lodash");
const { createDoc, expect } = require("../utils.js");
const { createXmlTemplaterDocxNoRender } = require("../xml-templater.js");
const { browserMatches } = require("../browser-utils.js");
const inspectModule = require("../../inspect-module.js");

const describeOnly = process.env.NODE_ENV !== "production" ? describe : describe.only;
const itOnly = process.env.NODE_ENV !== "production" ? it : it.only;

describeOnly("Speed test", () => {
  itOnly("should be fast for simple tags", async () => {
    const content = "<w:t>tag {age}</w:t>";
    const docs = _.times(100, () =>
      createXmlTemplaterDocxNoRender(content, {
        tags: {
          age: 12
        }
      })
    );
    const startTime = Date.now();
    await Promise.all(docs.map(doc => doc.render()));
    const duration = Date.now() - startTime;
    expect(duration).to.be.within(0, 400);
  });

  itOnly("should be fast for simple tags with huge content", async () => {
    const content = "<w:t>tag {age}</w:t>";
    const result = _.times(10000, () => "bla");
    const prepost = result.join("");
    content = prepost + content + prepost;
    const docs = _.times(20, () =>
      createXmlTemplaterDocxNoRender(content, {
        tags: {
          age: 12
        }
      })
    );
    const startTime = Date.now();
    await Promise.all(docs.map(doc => doc.render()));
    const duration = Date.now() - startTime;
    const maxDuration =
      browserMatches(/chrome (73|71)/) || browserMatches(/firefox (55|60|64|65)/)
        ? 600
        : 400;
    expect(duration).to.be.within(0, maxDuration);
  });

  itOnly("should be fast for loop tags", async () => {
    const content = "<w:t>{#users}{name}{/users}</w:t>";
    const users = _.times(1000, () => ({ name: "foo" }));
    const doc = createXmlTemplaterDocxNoRender(content, {
      tags: {
        users
      }
    });
    const startTime = Date.now();
    await doc.render();
    const duration = Date.now() - startTime;
    const maxDuration =
      browserMatches(/firefox (55|60|64|65)/) || browserMatches(/MicrosoftEdge (16)/)
        ? 150
        : 100;
    expect(duration).to.be.within(0, maxDuration);
  });

  itOnly("should be fast for nested loop tags", async () => {
    const result = _.times(300, i =>
      i % 1 === 0
        ? "<w:p><w:r><w:t>{@raw}</w:t></w:r></w:p>"
        : "<w:p><w:r><w:t>foo</w:t></w:r></w:p>"
    );
    const content = `<w:p><w:r><w:t>{#foo}</w:t></w:r>${result.join(
      ""
    )}<w:r><w:t>{/}</w:t></w:r></w:p>`;
    const users = [{ name: "John" }, { name: "Mary" }];
    const doc = createXmlTemplaterDocxNoRender(content, {
      tags: {
        users
      }
    });
    const startTime = Date.now();
    await doc.render();
    const duration = Date.now() - startTime;
    const maxDuration =
      browserMatches(/MicrosoftEdge (16|17|18)/) ||
      browserMatches(/internet explorer (10|11)/) ||
      browserMatches(/chrome (58|71|73|75)/) ||
      browserMatches(/iphone 10.3/)
        ? 500
        : 300;
    expect(duration).to.be.within(0, maxDuration);
  });

  itOnly(
    "should not exceed call stack size for big document with a few rawxml tags",
    { timeout: 30000 }
  );

  itOnly(
    "should not exceed call stack size for big document with many rawxml tags",
    { timeout: 30000 }
  );

  describe("Inspect module", () => {
    itOnly("should not be slow after multiple generations", { timeout: 30000 });

    itOnly(
      "should not be slow when having many loops with resolveData",
      { timeout: 30000 },
      async () => {
        const OldPromise = global.Promise;
        global.Promise = function(arg1, arg2) {
          return new OldPromise(arg1, arg2);
        };
        global.Promise.resolve = function(arg1) {
          return OldPromise.resolve(arg1);
        };
        global.Promise.all = function(arg1) {
          return OldPromise.all(arg1);
        };

        const doc = createDoc("multi-level.docx");
        doc.setOptions({
          paragraphLoop: true,
          parser: function parser(tag) {
            return {
              get: function get(scope) {
                return scope[tag];
              }
            };
          }
        });

        const start = Date.now();
        await doc.compile();
        const stepCompile = Date.now() - start;

        const multiplier = 20;
        const total = Math.pow(multiplier, 3);
        const data = {
          l1: _.times(multiplier),
          l2: _.times(multiplier),
          l3: _.times(multiplier, () => ({
            content: "Hello"
          }))
        };

        await doc.resolveData(data);

        const stepResolve = Date.now() - start;

        await doc.render();

        const stepRender = Date.now() - start;

        expect(stepCompile).to.be.within(0, 100);
        const maxResolveTime =
          browserMatches(/MicrosoftEdge (16|17|18)/)
            ? 20000
            : browserMatches(/firefox (55|89)/)
            ? 4000
            : 2000;
        expect(stepResolve).to.be.within(0, maxResolveTime);
        const maxRenderTime =
          browserMatches(/firefox (55|60|64|65|66|67)/) ||
          browserMatches(/iphone 10.3/) ||
          browserMatches(/MicrosoftEdge (16|17|18)/)
            ? 2000
            : 1000;
        expect(stepRender).to.be.within(0, maxRenderTime);

        global.Promise = OldPromise;
      }
    );
  });
});
