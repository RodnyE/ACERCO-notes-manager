"use strict";

const { expect } = require("chai");
const requireFromString = require("require-from-string");
const fs = require("fs");
const path = require("path");

const {
  cleanRecursive,
  errorVerifier,
  captureLogs,
} = require("../utils.js");

const {
  makeDocxV4,
  makePptxV4,
} = require("../maker.js");

const inspectModule = require("../inspect-module.js");
const AssertionModule = require("../assertion-module.js");

const runTest = async (fixture, async = false) => {
  fixture.options = fixture.options || {};
  const modules = [inspectModule(), new AssertionModule()];
  if (fixture.options.modules) {
    fixture.options.modules().forEach((mod) => {
      modules.push(mod);
    });
  }
  const doc = fixture.pptx
    ? makePptxV4(fixture.content, { ...fixture.options, modules })
    : makeDocxV4(fixture.content, { ...fixture.options, modules });
  doc.setData(fixture.scope);
  try {
    if (async === false) {
      doc.render();
    } else {
      await doc.renderAsync(fixture.scope);
    }
  } catch (error) {
    if (!fixture.error) {
      throw error;
    }
    errorVerifier(error, fixture.errorType, fixture.error);
    return;
  }
  cleanRecursive(doc.inspect);
  if (fixture.result !== undefined) {
    expect(doc.inspect.content).to.be.deep.equal(
      fixture.result,
      "Content incorrect"
    );
  }
  if (fixture.lexed !== undefined) {
    expect(doc.inspect.lexed).to.be.deep.equal(
      fixture.lexed,
      "Lexed incorrect"
    );
  }
  if (fixture.parsed !== undefined) {
    expect(doc.inspect.parsed).to.be.deep.equal(
      fixture.parsed,
      "Parsed incorrect"
    );
  }
  if (fixture.postparsed !== undefined) {
    expect(doc.inspect.postparsed).to.be.deep.equal(
      fixture.postparsed,
      "Postparsed incorrect"
    );
  }
  if (fixture.xmllexed !== undefined) {
    expect(doc.inspect.xmllexed).to.be.deep.equal(
      fixture.xmllexed,
      "Xmllexed incorrect"
    );
  }
  if (fixture.resolved !== undefined) {
    expect(doc.inspect.resolved).to.be.deep.equal(
      fixture.resolved,
      "Resolved incorrect"
    );
  }
};

const loadFixture = (name) => {
  const fixturePath = path.join(__dirname, "./fixtures", `${name}.js`);
  const fixtureSource = fs.readFileSync(fixturePath, "utf-8");
  const fixtureModule = requireFromString(fixtureSource);
  return fixtureModule.default;
};

describe("Algorithm", () => {
  beforeEach(() => {
    cleanRecursive(inspectModule().inspect);
  });

  afterEach(() => {
    cleanRecursive(inspectModule().inspect);
  });

  const fixtures = [
    // Add your fixtures here
  ];

  fixtures.forEach((fixture) => {
    const { it, onlySync, only, async: asyncFlag } = loadFixture(
      fixture.filename
    );
    if (onlySync) {
      it(it, () => runTest(fixture, false));
    }
    if (only) {
      it(`Async ${it}`, () => runTest(fixture, true));
    }
    if (!onlySync && !only) {
      it(it, () => runTest(fixture, false));
      it(`Async ${it}`, () => runTest(fixture, true));
    }
  });
});
