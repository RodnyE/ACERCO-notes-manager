"use strict";

const mocha = require("mocha");
const chai = require("chai");
const xmlMatcher = require("../../xml-matcher");
const xmlPrettify = require("../../xml-prettify");
const expect = chai.expect;

const xmlMatcherFixture = xmlMatcher("<root></root>");

describe("XmlMatcher", function () {
  this.timeout(5000);

  beforeEach(function () {
    xmlMatcherFixture.reset();
  });

  it.only("should work with simple tag", function () {
    const matcher = xmlMatcherFixture.match("<w:t>Text</w:t>", ["w:t"]);
    expect(matcher.matches[0].array).to.deep.equal(["<w:t>Text</w:t>", "<w:t>", "Text"]);
    expect(matcher.matches[0].offset).to.equal(0);
  });

  it.only("should work with multiple tags", function () {
    const matcher = xmlMatcherFixture.match("<w:t>Text</w:t> TAG <w:t>Text2</w:t>", ["w:t"]);
    expect(matcher.matches[1].array).to.deep.equal(["<w:t>Text2</w:t>", "<w:t>", "Text2"]);
    expect(matcher.matches[1].offset).to.equal(20);
  });

  it.only("should work with selfclosing tag", function () {
    const matcher = xmlMatcherFixture.match(' <w:spacing w:before="0" w:after="200"/> ', ["w:spacing"]);
    expect(matcher.matches.length).to.equal(1);
    expect(matcher.matches[0].array[0]).to.equal('<w:spacing w:before="0" w:after="200"/>');
  });

  it.only("should not match with no </w:t> starter", function () {
    const matcher = xmlMatcherFixture.match("TAG<w:t>Text1</w:t>", ["w:t"]);
    expect(matcher.matches[0].array).to.deep.equal(["<w:t>Text1</w:t>", "<w:t>", "Text1"]);
    expect(matcher.matches[0].offset).to.equal(3);
  });

  it.only("should not match with no <w:t> ender", function () {
    const matcher = xmlMatcherFixture.match("<w:t>Text1</w:t>TAG", ["w:t"]);
    expect(matcher.matches.length).to.equal(1);
  });
});

describe.only("XML prettify", function () {
  this.timeout(5000);

  it.only("should work with > inside attribute", function () {
    const str = xmlPrettify("<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n      <w:lvlText w:val=\">\"/>");
    expect(str.trim()).to.equal("<?xml version=\"1.0\" standalone=\"yes\"?>\n<w:lvlText w:val=\">\"/>");
  });

  it.only("should deduplicate xmlns:w", function () {
    const str = '<w:sectPr xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"><w:t xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"/></w:sectPr>';
    const prettified = xmlPrettify(str);
    expect(prettified.trim()).to.equal("<w:sectPr xmlns:w=\"http://schemas.openxmlformats.org/wordprocessingml/2006/main\">\n    <w:t />\n</w:sectPr>\n");
  });

  it.only("should normalize &#100;", function () {
    const str = '<w foo="Ry&#100;cy9Ry&#010;cy9"/>';
    const prettified = xmlPrettify(str);
    expect(prettified.trim()).to.equal("<w foo=\"Ry&#x64;cy9Ry&#xA;cy9\"/>\n");
  });

  it.only("should sort attributes", function () {
    const str = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?><foo zanc="bar" bar="foo"></foo><foo zak="foo" uk="bar"/>';
    const prettified = xmlPrettify(str);
    expect(prettified.trim()).to.equal("<?xml version=\"1.0
