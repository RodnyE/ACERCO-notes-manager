"use strict";

const chai = require("chai");
const mocha = require("mocha");
const { uniq, setSingleAttribute, getSingleAttribute, chunkBy } = require("../../doc-utils.js");
const { expect } = chai;
const { suite, test, beforeEach, afterEach } = mocha;

describe("Uniq", function () {
  this.timeout(5000);

  beforeEach(function () {
    this.sandbox = sinon.createSandbox();
  });

  afterEach(function () {
    this.sandbox.restore();
  });

  test("should return unique elements from an array", function () {
    const result = uniq(["a", "b", "a"]);
    expect(result).to.deep.equal(["a", "b"]);
  });
});

describe("setSingleAttribute", function () {
  this.timeout(5000);

  beforeEach(function () {
    this.sandbox = sinon.createSandbox();
  });

  afterEach(function () {
    this.sandbox.restore();
  });

  test("should set an attribute on a self-closing tag", function () {
    const result = setSingleAttribute("<a/>", "b", "true");
    expect(result).to.equal('<a b="true"/>');
  });

  test("should set an attribute on a starting tag", function () {
    const result = setSingleAttribute("<a>", "b", "true");
    expect(result).to.equal('<a b="true">');
  });

  test("should throw an error if the tag is not a string", function () {
    const fn = () => setSingleAttribute(123, "b", "true");
    expect(fn).to.throw("Tag must be a string");
  });

  test("should throw an error if the attribute name is not a string", function () {
    const fn = () => setSingleAttribute("<a>", 123, "true");
    expect(fn).to.throw("Attribute name must be a string");
  });

  test("should throw an error if the attribute value is not a string", function () {
    const fn = () => setSingleAttribute("<a>", "b", 123);
    expect(fn).to.throw("Attribute value must be a string");
  });
});

describe("getSingleAttribute", function () {
  this.timeout(5000);

  beforeEach(function () {
    this.sandbox = sinon.createSandbox();
  });

  afterEach(function () {
    this.sandbox.restore();
  });

  test("should get an attribute value from a tag", function () {
    const result = getSingleAttribute('<a b="c">', "b");
    expect(result).to.equal("c");
  });

  test("should return null if the attribute is not present", function () {
    const result = getSingleAttribute("<a>", "b");
    expect(result).to.equal(null);
  });

  test("should throw an error if the tag is not a string", function () {
    const fn = () => getSingleAttribute(123, "b");
    expect(fn).to.throw("Tag must be a string");
  });

  test("should throw an error if the attribute name is not a string", function () {
    const fn = () => getSingleAttribute("<a>", 123);
    expect(fn).to.throw("Attribute name must be a string");
  });
});

describe("ChunkBy", function () {
  this.timeout(5000);

  test("should chunk an array based on a function", function () {
    const chunks = chunkBy(
      [
        { type: "content", value: "Hello" },
        { type: "tag", tag: "w:t", position: "start" },
        { type: "content", value: "Ho" },
        { type: "tag", tag: "w:t", position: "end" },
        { type: "content", value: "Bye" },
      ],
      (part) => {
        if (part.type === "tag" && part.tag === "w:t") {
          return part.position;
        }
      }
    );
    expect(chunks).to.deep.equal([
      [
        { type: "content", value: "Hello" },
      ],
      [
        { type: "tag", tag: "w:t", position: "start" },
        { type: "content", value: "Ho" },
        { type: "tag", tag: "w:t", position: "end" },
      ],
      [
        { type: "content", value: "Bye" },
      ],
    ]);
  });

  test("should return an empty array if the input array is empty", function () {
    const chunks = chunkBy([], () => {});
    expect(chunks).to.deep.equal([]);
  });

  test("should return an array with one element if the input array has one element", function () {
    const chunks = chunkBy(["foo"], () => {});
    expect(chunks).to.deep.equal([["foo"]]);
  });

  test("should throw an error if the input array is not an array", function () {
    const fn = () => chunkBy("foo", () => {});
    expect(fn).to.throw("Input must be an array");
  });

  test("should throw an error if the chunking function is not a function", function () {
    const fn = () => chunkBy([], "foo");
    expect(fn).to.throw("Chunking function must be a function");
  });
});
