"use strict";

import DOMParser from "@xmldom/xmldom";
import { throwXmlTagNotFound } from "./errors";
import { last, first } from "./utils";

const charMap = [
  ["&", "&amp;"],
  ["<", "&lt;"],
  [">", "&gt;"],
  ['"', "&quot;"],
  ["'", "&apos;"],
];

const charMapRegexes = charMap.map(([endChar, startChar]) => ({
  rstart: new RegExp(startChar, "g"),
  rend: new RegExp(endChar, "g"),
  start: startChar,
  end: endChar,
}));

function wordToUtf8(string: string): string {
  for (const r of charMapRegexes) {
    string = string.replace(r.rstart, r.end);
  }
  return string;
}

function utf8ToWord(string: string): string {
  string = string.toString();
  for (const r of charMapRegexes) {
    string = string.replace(r.rend, r.start);
  }
  return string;
}

function concatArrays(arrays: any[][]): any[] {
  const result: any[] = [];
  for (let i = 0; i < arrays.length; i++) {
    const array = arrays[i];
    for (let j = 0, len = array.length; j < len; j++) {
      result.push(array[j]);
    }
  }
  return result;
}

function convertSpaces(s: string): string {
  return s.replace(spaceRegexp, " ");
}

const spaceRegexp = new RegExp(String.fromCharCode(160), "g");

function pregMatchAll(regex: RegExp, content: string): any[] {
  const matchArray: any[] = [];
  let match: RegExpExecArray | null;
  while ((match = regex.exec(content)) !== null) {
    matchArray.push({
      array: match,
      offset: match.index,
    });
  }
  return matchArray;
}

function isEnding(value: string, element: string): boolean {
  return value === "</" + element + ">";
}

function isStarting(value: string, element: string): boolean {
  return value.indexOf("<" + element) === 0 && ["<", " ", "/"].indexOf(value[element.length + 1]) !== -
