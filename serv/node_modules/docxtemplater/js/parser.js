import wordToUtf8 from "./doc-utils.js";
import match, { getValue, getValues } from "./prefix-matcher.js";

type Matcher = [string, (values: string[]) => object | null, object];

function getMatchers(modules: any[], options: any) {
  const matchers: Matcher[] = [];
  for (let i = 0, len = modules.length; i < len; i++) {
    const module = modules[i];
    if (module.matchers) {
      const mmm = module.matchers(options);
      if (!Array.isArray(mmm)) {
        throw new Error("module matcher returns a non array");
      }
      matchers.push(...mmm);
    }
  }
  return matchers;
}

function getMatches(matchers: Matcher[], placeHolderContent: string, options: any) {
  const matches: any[] = [];
  for (let i = 0, len = matchers.length; i < len; i++) {
    const [prefix, propertiesGetter, properties] = matchers[i];
    if (options.match(prefix, placeHolderContent)) {
      const values = options.getValues(prefix, placeHolderContent);
      const propertiesObj =
        typeof propertiesGetter === "function"
          ? propertiesGetter(values)
          : properties;
      if (!propertiesObj.value) {
        propertiesObj.value = values[1];
      }
      matches.push({
        type: "placeholder",
        prefix,
        module: matchers[i][1],
        onMatch: propertiesObj.onMatch,
        priority: propertiesObj.priority,
        value: propertiesObj.value,
      });
    }
  }
  return matches;
}

interface ModuleParsed {
  type: string;
  value: any;
  offset: number;
  endLindex: number;
  lIndex: number;
  raw?: string;
  onMatch?: (parsed: any) => void;
}

function moduleParse(
  placeHolderContent: string,
  options: any
): ModuleParsed | null {
  const modules = options.modules;
  const startOffset = options.startOffset;
  const endLindex = options.lIndex;
  options.offset = startOffset;
  options.match = match;
  options.getValue = getValue;
  options.getValues = getValues;
  const matchers = getMatchers(modules, options);
  const matches = getMatches(matchers, placeHolderContent, options);
  if (matches.length > 0) {
    const bestMatch = matches.reduce((best, match) => {
      match.priority = match.priority || -match.value.length;
      return best.priority > match.priority ? best : match;
    });
    bestMatch.offset = startOffset;
    delete bestMatch.priority;
    bestMatch.endLindex = endLindex;
    bestMatch.lIndex = endLindex;
    bestMatch.raw = placeHolderContent;
    if (bestMatch.onMatch) {
      bestMatch.onMatch(bestMatch);
    }
    delete bestMatch.onMatch;
    delete bestMatch.prefix;
    return bestMatch;
  }
  for (let i = 0, l = modules.length; i < l; i++) {
    const moduleParsed = modules[i].parse(placeHolderContent, options);
    if (moduleParsed) {
      moduleParsed.offset = startOffset;
      moduleParsed.endLindex = endLindex;
      moduleParsed.lIndex = endLindex;
      moduleParsed.raw = placeHolderContent;
      return moduleParsed;
    }
  }
  return {
    type: "placeholder",
    value: placeHolderContent,
    offset: startOffset,
    endLindex: endLindex,
    lIndex: endLindex,
  };
}

interface ParserOptions {
  modules: any[];
  startOffset: number;
  lIndex: number;
  fileTypeConfig: {
    droppedTagsInsidePlaceholder?: string[];
  };
  parse?: (placeHolderContent: string) => ModuleParsed;
  offset?: number;
  match: (prefix: string, placeHolderContent: string) => boolean;
  getValues: (prefix: string, placeHolderContent: string) => string[];
}

interface ParsedToken {
  type: string;
  value?: string;
  offset?: number;
  endLindex?: number;
  lIndex?: number;
  tag?: string;
  position?: string;
}

interface PreparsedOptions extends ParserOptions {
  preparsed: any[];
}

interface PostparsedOptions extends ParserOptions {
  postparsed: any[];
  errors: any[];
}

const parser = {
  preparse: (parsed: ParsedToken[], modules: any[], options: PreparsedOptions) => {
    return {
      preparsed: modules.forEach((module) => {
        module.preparse(parsed, options);
      }),
    };
  },
  parse: (
    lexed: ParsedToken[],
    modules: any[],
    options: ParserOptions
  ): ParsedToken[] => {
    let inPlaceHolder = false;
    let placeHolderContent = "";
    let startOffset;
    const tailParts: ParsedToken[] = [];
    const droppedTags =
      options.fileTypeConfig.droppedTagsInsidePlaceholder || [];
    return lexed.reduce((parsed, token) => {
      if (token.type === "delimiter") {
        inPlaceHolder = token.position === "start";
        if (token.position === "end") {
          options.parse = (placeHolderContent) =>
            moduleParse(placeHolderContent, {
              ...options,
              startOffset,
              modules,
            });
          parsed.push(options.parse(wordToUtf8(placeHolderContent)));
          Array.prototype.push.apply(parsed, tailParts);
          tailParts = [];
        }
        if (token.position === "start") {
          tailParts = [];
          startOffset = token.offset;
        }
        placeHolderContent = "";
        return parsed;
      }
      if (!inPlaceHolder) {
        parsed.push(token);
        return parsed;
      }
      if (token.type !== "content" || token.position !== "insidetag") {
        if (droppedTags.indexOf(token.tag) !== -1) {
          return parsed;
        }
        tailParts.push(token);
        return parsed;
      }
      placeHolderContent += token.value;
      return parsed;
    }, []);
  },
  postparse: (
    postparsed: any[],
    modules: any[],
    options: PostparsedOptions
  ): PostparsedOptions => {
    const errors: any[] = [];
    const getTraits = (traitName: string, postparsed: any[]) =>
      modules.map((module) => module.getTraits(traitName, postparsed));

    const _postparse = (postparsed: any[], options: PostparsedOptions) =>
      modules.reduce(
        (postparsed, module) => {
          const r = module.postparse(postparsed, {
            ...options,
            postparse: (parsed, opts) =>
              _postparse(parsed, { ...options, ...opts }),
            getTraits,
          });
          if (r == null) {
            return postparsed;
          }
          if (r.errors) {
            Array.prototype.push.apply(errors, r.errors);
            return r.postparsed;
          }
          return r;
        },
        postparsed
      );

    return {
      postparsed: _postparse(postparsed, options),
      errors,
    };
  },
};

export default parser;
