"use strict";

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}

const { setSingleAttribute } = require("../doc-utils.js");
const { isTagStart } = require("../xml-utils.js");

const FixDocPRCorruptionModule = /*#__PURE__*/ (() => {
  class FixDocPRCorruptionModule {
    constructor() {
      _classCallCheck(this, FixDocPRCorruptionModule);
      this.name = "FixDocPRCorruptionModule";
      this.Lexer = null;
      this.zip = null;
      this.xmlDocuments = {};
    }

    clone() {
      return new FixDocPRCorruptionModule();
    }

    set(options) {
      if (options.Lexer) {
        this.Lexer = options.Lexer;
      }
      if (options.zip) {
        this.zip = options.zip;
      }
      if (options.xmlDocuments) {
        this.xmlDocuments = options.xmlDocuments;
      }
    }

    on(event) {
      if (event !== "syncing-zip") {
        return;
      }

      const zip = this.zip;
      const Lexer = this.Lexer;
      let prId = 1;

      zip.file(/.xml$/).forEachOf((file) => {
        try {
          const text = file.asText();
          const xmlDoc = this.xmlDocuments[file.name];

          if (xmlDoc) {
            const prs = xmlDoc.getElementsByTagName("wp:docPr");
            for (let i = 0, len = prs.length; i < len; i++) {
              const pr = prs[i];
              pr.setAttribute("id", prId++);
            }
            return;
          }

          let xmllexed = Lexer.xmlparse(text, {
            text: [],
            other: ["wp:docPr"],
          });

          if (xmllexed.length > 1) {
            let text = "";
            xmllexed.forEach((part) => {
              if (isTagStart("wp:docPr", part)) {
                const id = prId++;
                text += setSingleAttribute(part.value, "id", id);
              } else {
                text += part.value;
              }
            });
            zip.file(file.name, text);
          }
        } catch (error) {
          console.error(`Error processing file ${file.name}:`, error);
        }
      });
    }
  }

  return FixDocPRCorruptionModule;
})();

module.exports = new FixDocPRCorruptionModule();
