"use strict";

const traits = require("../traits.js");
const { isContent } = require("../doc-utils.js");
const {
  throwRawTagShouldBeOnlyTextInParagraph,
  getInvalidRawXMLValueException
} = require("../errors.js");
const _typeof = require("@babel/types").typeof;

const rawXmlModule = /*#__PURE__*/ (() => {
  function RawXmlModule() {
    _classCallCheck(this, RawXmlModule);
    this.name = "RawXmlModule";
    this.prefix = "@";
  }

  _createClass(RawXmlModule, [
    {
      key: "optionsTransformer",
      value: function optionsTransformer(options, docxtemplater) {
        this.fileTypeConfig = docxtemplater.fileTypeConfig;
        return options;
      }
    },
    {
      key: "matchers",
      value: function matchers() {
        return [[this.prefix, "rawxml"]];
      }
    },
    {
      key: "postparse",
      value: function postparse(postparsed) {
        return traits.expandToOne(postparsed, {
          moduleName: "rawxml",
          getInner: getInner,
          expandTo: this.fileTypeConfig.tagRawXml,
          error: {
            message: "Raw tag not in paragraph",
            id: "raw_tag_outerxml_invalid",
            explanation: function explanation(part) {
              return `The tag "${part.value}" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.`;
            }
          }
        });
      }
    },
    {
      key: "render",
      value: function render(part, options) {
        if (part.module !== "rawxml") {
          return null;
        }

        let value;
        const errors = [];

        try {
          value = options.scopeManager.getValue(part.value, {
            part: part
          });
          if (value == null) {
            value = options.nullGetter(part);
          }
        } catch (e) {
          errors.push(e);
          return {
            errors: errors
          };
        }

        value = value ? value : "";

        if (typeof value === "string") {
          return {
            value: value
          };
        }

        return {
          errors: [getInvalidRawXMLValueException({
            tag: part.value,
            value: value,
            offset: part.offset
          })]
        };
      }
    }
  ]);

  return RawXmlModule;
})();

const getInner = ({ part, left, right, postparsed, index }) => {
  const paragraphParts = postparsed.slice(left + 1, right);
  paragraphParts.forEach((p, i) => {
    if (i === index - left - 1) {
      return;
    }

    if (isContent(p)) {
      throwRawTagShouldBeOnlyTextInParagraph({
        paragraphParts: paragraphParts,
        part: part
      });
    }
  });

  return part;
};

module.exports = function () {
  return wrapper(new rawXmlModule());
};
