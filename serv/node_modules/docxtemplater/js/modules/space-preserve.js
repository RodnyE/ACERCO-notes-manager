"use strict";

const { isTextStart, isTextEnd } = require("../doc-utils.js");
const wTpreserve = '<w:t xml:space="preserve">';
const wTpreservelen = wTpreserve.length;
const wtEnd = "</w:t>";
const wtEndlen = wtEnd.length;

function isWtStart(part) {
  return isTextStart(part) && part.tag === "w:t";
}

function addXMLPreserve(chunk, index) {
  const tag = chunk[index].value;
  if (chunk[index + 1].value === "</w:t>") {
    return tag;
  }
  if (tag.indexOf('xml:space="preserve"') !== -1) {
    return tag;
  }
  return tag.substr(0, tag.length - 1) + ' xml:space="preserve">';
}

function isInsideLoop(meta, chunk) {
  return meta && meta.basePart && chunk.length > 1;
}

const SpacePreserve = /*#__PURE__*/ (() => {
  function SpacePreserve() {
    this.name = "SpacePreserveModule";
  }

  SpacePreserve.prototype.clone = function clone() {
    return new SpacePreserve();
  };

  SpacePreserve.prototype.postparse = function postparse(postparsed, meta) {
    let chunk = [];
    let inTextTag = false;
    let endLindex = 0;
    let lastTextTag = 0;

    const isStartingPlaceHolder = (part, chunk) =>
      part.type === "placeholder" && chunk.length > 1;

    const result = postparsed.reduce((postparsed, part) => {
      if (isWtStart(part)) {
        inTextTag = true;
        lastTextTag = chunk.length;
      }

      if (!inTextTag) {
        postparsed.push(part);
        return postparsed;
      }

      chunk.push(part);

      if (isInsideLoop(meta, chunk)) {
        endLindex = meta.basePart.endLindex;
        chunk[0].value = addXMLPreserve(chunk, 0);
      }

      if (isStartingPlaceHolder(part, chunk)) {
        chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);
        endLindex = part.endLindex;
      }

      if (isTextEnd(part) && part.lIndex > endLindex) {
        if (endLindex !== 0) {
          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);
        }

        Array.prototype.push.apply(postparsed, chunk);
        chunk = [];
        inTextTag = false;
        endLindex = 0;
        lastTextTag = 0;
      }

      return postparsed;
    }, []);

    Array.prototype.push.apply(result, chunk);
    return result;
  };

  SpacePreserve.prototype.postrender = function postrender(parts) {
    let lastNonEmpty = "";
    let lastNonEmptyIndex = 0;

    for (let i = 0, len = parts.length; i < len; i++) {
      const index = i;
      const p = parts[i];

      if (p === "") {
        continue;
      }

      if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {
        parts[lastNonEmptyIndex] =
          lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + "<w:t/>";
        p = p.substr(wtEndlen);
      }

      lastNonEmpty = p;
      lastNonEmptyIndex = index;
      parts[i] = p;
    }

    return parts;
  };

  return SpacePreserve;
})();

module.exports = function () {
  return wrapper(new SpacePreserve());
};
